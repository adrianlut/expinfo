#!/usr/bin/env python3

import asyncio
from asyncio.exceptions import IncompleteReadError
from collections import defaultdict
import json
import traceback
import os
import config


__location__ = os.path.realpath(os.path.join(
    os.getcwd(), os.path.dirname(__file__)))


class KVStore:
    def __init__(self):
        self.__db = {}

    def insert(self, key, value):
        if key in self.__db:
            raise Exception(f'Key: {key} already exists')
        self.__db[key] = value

    def update(self, key, value):
        if key not in self.__db:
            raise Exception(f'Key: {key} does not exist')
        if isinstance(self.__db[key], dict):
            self.__db[key].update(value)
            return
        self.__db[key] = value

    def read(self):
        return self.__db

    def delete(self, key):
        if key not in self.__db:
            raise Exception(f'Key: {key} does not exist')
        del self.__db[key]

    def delete_many(self, keys):
        for k in keys:
            if k not in self.__db:
                continue
            del self.__db[k]


class UndoLog:
    def __init__(self, db):
        self.__db = db
        self.__keys = set()

    def add(self, msg):
        if msg['method'] in ['insert']:
            self.__keys.add(msg['key'])

    def undo(self):
        if self.__keys:
            print(f'deleting entries: {self.__keys}')
            self.__db.delete_many(self.__keys)


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


class PromptUpdater:
    def __init__(self, db):
        self.db = db
        self.filename = os.path.join(__location__, 'prompt')

    def update(self, msg=None):
        if msg is not None and msg['method'] not in ['insert', 'update', 'delete', 'delete_many']:
            return

        f = open(self.filename, 'w')

        entries = self.db.read()
        if not entries:
            return

        # 🔴 🟡 🟢 \033[0;31m ● job 1\033[0m\n
        for entry in entries.values():
            if entry['exclusive']:
                f.write(
                    f'{bcolors.BOLD}{bcolors.FAIL}*** EXCLUSIVE ACCESS by{bcolors.ENDC} {bcolors.OKBLUE}{entry["user"]}{bcolors.ENDC} {bcolors.BOLD}{bcolors.FAIL}***{bcolors.ENDC}')
                f.write('\\n')
                return

        n = len(entries)
        plural = 's' if n > 1 else ''
        info = ', '.join(set(x['user'] for x in entries.values()))
        f.write(
            f'{bcolors.WARNING}{n} job{plural} running from {bcolors.OKBLUE}{info}{bcolors.WARNING}!{bcolors.ENDC}')
        f.write('\\n')


class MotdUpdater:
    def __init__(self, db):
        self.db = db
        self.filename = os.path.join(__location__, 'motd')

    def update(self, msg=None):
        if msg is not None and msg['method'] not in ['insert', 'update', 'delete', 'delete_many']:
            return

        f = open(self.filename, 'w')

        f.write('{}Experiment Job Manager: {} --help{}\n'.format(bcolors.OKGREEN,
                                                                 config.EXE_NAME, bcolors.ENDC))
        f.write('\n')
        f.write('{}Please register all processes you start!{}\n'.format(
            bcolors.WARNING, bcolors.ENDC))
        f.write('\n')

        entries = self.db.read()
        if not entries:
            return

        f.write('{}{}Currently the following experiments are running:{}\n'.format(
            bcolors.BOLD, bcolors.FAIL, bcolors.ENDC))
        for _id, exp in entries.items():
            f.write(self.get_fmt_exp(_id=_id, **exp))
            f.write('\n\n')

    def get_fmt_exp(self, _id, user, start, end, cmd, msg, exclusive, pid, numa='?'):
        line = ''

        if exclusive:
            line += '\n{}*** EXCLUSIVE ACCESS ***{}\n'.format(
                bcolors.FAIL, bcolors.ENDC)

        line += '{}{:<15}{} {}Start:{} {}'.format(
            bcolors.WARNING, user, bcolors.ENDC, bcolors.OKBLUE, bcolors.ENDC, start)
        line += ' {}NUMA:{} {} {}PID:{} {}'.format(
            bcolors.OKBLUE, bcolors.ENDC, numa, bcolors.OKBLUE, bcolors.ENDC, pid)
        line += '\n{}Message:{} {}'.format(bcolors.OKBLUE, bcolors.ENDC, msg)
        line += '\n{}Exec:{} {}'.format(bcolors.OKBLUE, bcolors.ENDC, cmd)

        if exclusive:
            line += '\n{}*** EXCLUSIVE ACCESS ***{}'.format(
                bcolors.FAIL, bcolors.ENDC)

        return line


class Daemon(dict):
    def __init__(self):
        self.__db = KVStore()
        self.__prompt = PromptUpdater(self.__db)
        self.__motd = MotdUpdater(self.__db)

    async def handle_msg(self, log, msg, send):
        ret = None
        try:
            fn = getattr(self.__db, msg['method'])
            kwargs = {x: msg[x]
                      for x in fn.__code__.co_varnames if x != 'self'}
            ret = fn(**kwargs)
            log.add(msg)
            self.__prompt.update(msg)
            self.__motd.update(msg)
        except Exception as e:
            print(traceback.format_exc())
            await send({'error': traceback.format_exc(limit=0)})
            return

        if ret is None:
            await send({'error': None})
            return
        await send(ret)

    async def handle(self, reader, writer):
        addr = writer.get_extra_info('peername')
        print(f'Connection from: {addr[0]}:{addr[1]}')
        log = UndoLog(self.__db)

        async def send(msg):
            if writer.is_closing():
                return False
            j = json.dumps(msg)
            print(f'Send: {j}')
            writer.write(j.encode())
            writer.write(b'\n')
            await writer.drain()
            return True

        while True:
            try:
                data = await reader.readuntil(separator=b'\n')
            except (IncompleteReadError, ConnectionResetError):
                break

            try:
                msg = json.loads(data[:-1])
            except json.decoder.JSONDecodeError:
                await send({'error': 'json.decoder.JSONDecodeError'})
                break

            print(f'Received {msg} from {addr[0]}:{addr[1]}')
            await self.handle_msg(log, msg, send)

        writer.close()
        await writer.wait_closed()
        print(f'Closed connection: {addr[0]}:{addr[1]}')

        # on disconnect remove all inserted data items
        log.undo()
        self.__prompt.update()
        self.__motd.update()


daemon = Daemon()

loop = asyncio.get_event_loop()
coro = asyncio.start_server(
    daemon.handle, config.DAEMON_IP, config.DAEMON_PORT, loop=loop)
server = loop.run_until_complete(coro)

# Serve requests until Ctrl+C is pressed
addr = server.sockets[0].getsockname()
print(f'Serving on: {addr[0]}:{addr[1]}')
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

# Close the server
server.close()
loop.run_until_complete(server.wait_closed())
loop.close()
